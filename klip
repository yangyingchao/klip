#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import wx.lib.mixins.listctrl as listmix
import os
import sqlite3
import re
import wx
import codecs


def getClipPath():
    """Return path of "My Clippings.txt", written by Kindle.
    """

    if sys.platform == 'darwin':
        return "/Volumes/Kindle/documents/My Clippings.txt"

    raise Exception("Platform %s not support." % sys.platform)


def getDBPath(readonly=False):
    """Return path of database.
    """
    if sys.platform == 'darwin':
        path = '%s/Library/Application Support/Klip/' % os.getenv("HOME")
    else:
        raise Exception("Platform %s not support." % sys.platform)

    if not os.path.exists(path):
        os.mkdir(path)
    path += 'klip.db'

    if readonly:
        path += '?mode = ro'

    return path


def myhash(value):
    """

    Arguments:
    - `value`:
    """
    return hash(value) % ((sys.maxsize + 1) * 2)


boms = [codecs.BOM_UTF8]
reps = [('（', '('), ('）', ')'), ('（', '('), ('）', ')')]
r_match_book = re.compile('(.*?)\(.*?\)', re.DOTALL)


def process_book_name(name):
    """
    Process book name.
    Arguments:
    - `name`:
    """

    # replace some  charachters.
    for (k, v) in reps:
        name = name.replace(k, v)

    # merge multiple white spaces
    name = ' '.join(name.strip().split())

    m = r_match_book.match(name)
    if m:
        name = m.group(1)

        # remove BOMs first
    for bom in boms:
        if name.startswith(bom):
            name = name[len(bom):]

    return name.strip()


R_MATCH_ENTRY = re.compile(
    u'^(.*?)\n- (.*?) \\| (.*?)\n(.*?)\n==========', re.DOTALL | re.MULTILINE)

CLIP_TABLE = 'clippings'

CLIP_CREATE = '''
create table if not exists %s
    (
      ID BIGINT PRIMARY KEY NOT NULL,
      BOOK TEXT,
      POSITION TEXT,
      TIMESTAMP TEXT,
      CONTENT TEXT
    );
''' % CLIP_TABLE

CLIP_INSERT_FMT = 'insert into %s values ' % CLIP_TABLE + \
    '''(%u, '%s', '%s', '%s', '%s');'''

QUERY_CLIP_FROM_ID = "select id, book from %s where ID = " % CLIP_TABLE + "%u"
QUERY_CLIP_FROM_BOOK = u"select content from %s where BOOK = " % CLIP_TABLE + "'%s'"

BOOK_TABLE = 'books'
BOOK_CREATE = '''
create table if not exists %s
(
      ID BIGINT PRIMARY KEY NOT NULL,
      BOOK TEXT
)
''' % BOOK_TABLE
BOOK_INSERT_FMT = 'insert into %s values ' % BOOK_TABLE + \
    '''(%u, '%s');'''
QUERY_BOOK_FMT = "select id, book from %s where ID = " % BOOK_TABLE + "%u"


class KlipModel(object):
    def __init__(self, readonly=False):
        """
        """
        super(KlipModel, self).__init__()
        self.conn = sqlite3.connect(getDBPath(readonly))
        self.c = self.conn.cursor()
        self.execute(CLIP_CREATE, True)
        self.execute(BOOK_CREATE, True)

    def execute(self, sql, commit=True):
        """
        Execute sql, and commit commit if asked.
        """
        try:
            self.c.execute(sql)
        except sqlite3.IntegrityError as e:
            print('DUP: %s' % e)
        except Exception as e:
            print('FATAL: %s -- %s' % (e, sql))
            exit(1)

        if commit:
            self.conn.commit()

        return self.c

    def __del__(self):
        """
        """
        self.conn.commit()
        self.conn.close()
        pass

    def loadFile(self, path):
        """Load clippings from file.

        Arguments:

        - `path`: path of file
        """
        books_added = 0
        records_added = 0

        with open(path) as fd:
            while True:
                content = fd.read(PAGE_SIZE)
                if content is None:
                    break
                if len(content) == 0:
                    break
                pos = 0
                while True:
                    m = R_MATCH_ENTRY.search(content, pos)
                    if m is None:
                        new_content = fd.read(PAGE_SIZE)
                        if len(new_content) == 0:
                            print('New books: %d, new records: %d' %
                                  (books_added, records_added))
                            print('EOF reached...')
                            return (books_added, records_added)
                        else:
                            content = content[pos:] + new_content
                            pos = 0
                    else:
                        book = handleStr(process_book_name(m.group(1)))
                        page = handleStr(m.group(2).strip())
                        time = handleStr(m.group(3).strip())
                        mark = handleStr(m.group(4).strip())
                        pos = m.end(0)

                        if len(mark) == 0:
                            continue

                        value = book + "_" + mark

                        clip_key = myhash(value)
                        book_key = myhash(book)

                        cur = self.execute(QUERY_BOOK_FMT % book_key)
                        row = cur.fetchone()

                        if row is None:
                            self.execute(BOOK_INSERT_FMT %
                                         (book_key, book),
                                         False)
                            books_added += 1
                            print('New book detected: %s, key: %d' %
                                  (book, book_key))
                            if book.startswith(boms[0]):
                                print('BOM....')
                                return 1
                            pass

                        cur = self.execute(
                            QUERY_CLIP_FROM_ID % (clip_key))
                        row = cur.fetchone()

                        if row is None:
                            self.execute(CLIP_INSERT_FMT %
                                         (clip_key, book, page, time, mark),
                                         False)
                            records_added += 1

        pass

    def cleanup(self):
        """ Clean up model and database.
        """
        pass


def handleStr(ins):
    """

    Arguments:
    - `s`:
    """
    ins.strip()

    out = ''

    for s in ins:
        if s == "'":
            s = '"'
        out += s
    return out


PAGE_SIZE = 4096


class BookListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin):
    def __init__(self, parent, ID, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.LC_REPORT):
        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
        listmix.ListCtrlAutoWidthMixin.__init__(self)


class KlipFrame(wx.Frame):
    """
    """

    def __init__(self):
        """
        """

        super(KlipFrame, self).__init__(None, size=wx.Size(1200, 760))
        # ensure the parent's __init__ is called

        self.model = KlipModel()
        self.SetMinSize(wx.Size(800, 600))

        sp = wx.SplitterWindow(self, style=wx.SP_BORDER | wx.SP_3DBORDER)
        sp.SetSplitMode(wx.SPLIT_VERTICAL)
        sp.SetMinimumPaneSize(50)

        # create a panel in the frame
        pnl_books = wx.Panel(sp)
        pnl_clips = wx.Panel(sp)
        pnl_clips.SetBackgroundColour(wx.Colour(255, 255, 255))

        sp.SplitVertically(pnl_books, pnl_clips, int(
            round(self.GetSize().GetWidth() * 0.3)))

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(wx.Button(pnl_books, -1, 'Search box will be here'),
                  0, wx.EXPAND, 0)

        self.book_list = BookListCtrl(pnl_books,
                                      wx.ID_ANY,
                                      style=wx.LC_REPORT | wx.LC_NO_HEADER |
                                      wx.LC_HRULES | wx.LC_SINGLE_SEL)
        books = self.FillBooks()

        font = self.book_list.GetFont()
        font.PointSize += 5
        # font = font.Bold()
        self.book_list.SetFont(font)
        self.book_list.SetForegroundColour(wx.Colour(0x43, 0x43, 0x43))

        self.Bind(wx.EVT_LIST_ITEM_SELECTED,
                  self.OnBookSelected, self.book_list)

        st2 = wx.StaticText(pnl_books, label="BOOKS (%d)" %
                            books, pos=(25, 25))

        sizer.Add(st2, 0, wx.LEFT, 0)

        sizer.Add(self.book_list, 1, wx.EXPAND | wx.ALL, 0)

        # pnl_books.SetAutoLayout(True)
        pnl_books.SetSizer(sizer)

        # init right panel, show clippings.
        sizer = wx.BoxSizer(wx.VERTICAL)
        self.book_title = wx.StaticText(
            pnl_clips, label='')

        font = self.book_title.GetFont()
        font.PointSize += 10
        font.Bold()
        self.book_title.SetFont(font)
        self.book_title.SetForegroundColour(wx.Colour(0x25, 0x91, 0xff))

        sizer.Add(self.book_title,
                  0, wx.EXPAND, 0)

        self.clip_list = BookListCtrl(pnl_clips,
                                      wx.ID_ANY,
                                      style=wx.LC_REPORT | wx.LC_NO_HEADER |
                                      wx.LC_HRULES | wx.LC_SINGLE_SEL)
        books = self.FillBooks()

        sizer.Add(self.clip_list, 1, wx.EXPAND | wx.ALL, 0)

        pnl_clips.SetSizer(sizer)

        font = self.clip_list.GetFont()
        font.PointSize += 3
        self.clip_list.SetFont(font)

        # create a menu bar
        self.makeMenuBar()

        if books > 0:
            self.book_list.Select(0)

    def makeMenuBar(self):
        """
        A menu bar is composed of menus, which are composed of menu items.
        This method builds a set of menus and binds handlers to be called
        when the menu item is selected.
        """

        # Make a file menu with Hello and Exit items
        fileMenu = wx.Menu()
        # The "\t..." syntax defines an accelerator key that also triggers
        # the same event
        loadItem = fileMenu.Append(-1, "&Load...\tCtrl-L",
                                   "Load clippings...")
        fileMenu.AppendSeparator()
        # When using a stock ID we don't need to specify the menu item's
        # label
        exitItem = fileMenu.Append(wx.ID_EXIT)

        # Now a help menu for the about item
        helpMenu = wx.Menu()
        aboutItem = helpMenu.Append(wx.ID_ABOUT)

        # Make the menu bar and add the two menus to it. The '&' defines
        # that the next letter is the "mnemonic" for the menu item. On the
        # platforms that support it those letters are underlined and can be
        # triggered from the keyboard.
        menuBar = wx.MenuBar()
        menuBar.Append(fileMenu, "&File")
        menuBar.Append(helpMenu, "&Help")

        # Give the menu bar to the frame
        self.SetMenuBar(menuBar)

        # Finally, associate a handler function with the EVT_MENU event for
        # each of the menu items. That means that when that menu item is
        # activated then the associated handler function will be called.
        self.Bind(wx.EVT_MENU, self.OnLoadFile, loadItem)
        self.Bind(wx.EVT_MENU, self.OnExit,  exitItem)
        self.Bind(wx.EVT_MENU, self.OnAbout, aboutItem)

    def OnExit(self, event):
        """Close the frame, terminating the application."""
        self.Close(True)

    def OnLoadFile(self, event):
        """Say hello to the user."""

        path = getClipPath()
        if not os.path.exists(path):
            path = "/Volumes/yyc/Documents/My Clippings.txt"

        self.model.loadFile(path)
        self.FillBooks()
        wx.MessageBox("Hello again from wxPython")

    def OnAbout(self, event):
        """Display an About Dialog"""
        wx.MessageBox("This is a wxPython Hello World sample",
                      "About Hello World 2",
                      wx.OK | wx.ICON_INFORMATION)

    def FillBooks(self):
        """Fill book list.
        """

        self.book_list.ClearAll()
        self.book_list.SetBackgroundColour(wx.Colour(0xf6, 0xf6, 0xf6))

        self.book_list.InsertColumn(0, "Book")
        # 0 will insert at the start of the list

        cur = self.model.execute('select book from %s' % BOOK_TABLE)
        idx = 0

        while True:
            r = cur.fetchone()
            if r is None:
                break
            book = r[0]
            self.book_list.InsertStringItem(idx, u"   %s" % (book))
            idx += 1

        width = self.book_list.GetSize().GetWidth()*0.5
        print('WIDTH: %d' % (width))
        self.book_list.SetColumnWidth(0, width)
        # self.book_list.SetFont(wx.Font(32, wx.FONTFAMILY_MODERN,
        #                                wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))

        return idx

    def OnBookSelected(self, event):
        """
        """
        currentItem = event.m_itemIndex
        book = self.book_list.GetItemText(currentItem).strip()

        self.book_title.SetLabel("  %s" % book)
        self.clip_list.ClearAll()
        self.clip_list.InsertColumn(0, "Clip")

        sql = QUERY_CLIP_FROM_BOOK % book
        cur = self.model.execute(sql)
        idx = 0
        while True:
            r = cur.fetchone()
            if r is None:
                break

            clip = r[0]
            self.clip_list.InsertStringItem(idx, u"    %s" % (clip))
            idx += 1

        self.clip_list.SetColumnWidth(0, -2)

        pass


if __name__ == '__main__':
    app = wx.App()
    frm = KlipFrame()

    # Show it.
    frm.Show()

    app.MainLoop()
