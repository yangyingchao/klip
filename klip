#!/usr/bin/env python

import sys
import os
import sqlite3
import re
import wx

verbose = False


def getClipPath():
    """Return path of "My Clippings.txt", written by Kindle.
    """

    if sys.platform == 'darwin':
        return "/Volumes/Kindle/documents/My Clippings.txt"

    raise Exception("Platform %s not support." % sys.platform)


def getDBPath(readonly=False):
    """Return path of database.
    """
    if sys.platform == 'darwin':
        path = '%s/Library/Application Support/Klip/' % os.getenv("HOME")
    else:
        raise Exception("Platform %s not support." % sys.platform)

    if not os.path.exists(path):
        os.mkdir(path)
    path += 'klip.db'

    if readonly:
        path += '?mode = ro'

    return path


R_MATCH_ENTRY = re.compile(
    u'^(.*?)\n- (.*?) \\| (.*?)\n(.*?)\n==========', re.DOTALL | re.MULTILINE)

TABLE_NAME = 'my_clippings'

SQL_CREATE = '''
create table if not exists %s
    (
      ID BIGINT PRIMARY KEY NOT NULL,
      BOOK TEXT,
      POSITION TEXT,
      TIMESTAMP TEXT,
      CONTENT TEXT
    );
''' % TABLE_NAME

INSERT_FMT = 'insert into %s values ' % TABLE_NAME + \
    '''(%u, '%s', '%s', '%s', '%s');'''


QUERY_FMT = "select id, book from %s where ID = " % TABLE_NAME + "%u"


class Database(object):
    def __init__(self, readonly=False):
        """
        """
        super(Database, self).__init__()
        self.conn = sqlite3.connect(getDBPath(readonly))
        self.c = self.conn.cursor()
        self.execute(SQL_CREATE, True)

    def execute(self, sql, commit=True):
        """
        Execute sql, and commit commit if asked.
        """
        try:
            self.c.execute(sql)
        except sqlite3.IntegrityError as e:
            print('DUP: %s' % e)
        except Exception as e:
            print('FATAL: %s -- %s' % (e, sql))
            exit(1)

        if commit:
            self.conn.commit()

        return self.c

    def __del__(self):
        """
        """
        self.conn.commit()
        self.conn.close()
        pass


def handleStr(ins):
    """

    Arguments:
    - `s`:
    """
    ins.strip()

    out = ''

    for s in ins:
        if s == "'":
            s = '"'
        out += s
    return out


PAGE_SIZE = 4096


def main():
    path = getClipPath()
    if not os.path.exists(path):
        path = "/Volumes/yyc/Documents/My Clippings.txt"

    db = Database()

    with open(path) as fd:
        while True:
            content = fd.read(PAGE_SIZE)
            if content is None:
                break
            if len(content) == 0:
                break
            pos = 0
            while True:
                m = R_MATCH_ENTRY.search(content, pos)
                if m is None:
                    # print('Match failed, pos: %d, content: %s' % (pos,
                    #                                               content[pos:]))

                    new_content = fd.read(PAGE_SIZE)
                    if len(new_content) == 0:
                        print('EOF reached...')
                        sys.exit(1)
                    else:
                        content = content[pos:] + new_content
                        pos = 0
                else:
                    book = handleStr(m.group(1).strip())
                    page = handleStr(m.group(2).strip())
                    time = handleStr(m.group(3).strip())
                    mark = handleStr(m.group(4).strip())
                    pos = m.end(0)

                    if len(mark) == 0:
                        continue

                    value = book + "_" + mark
                    key = hash(value) % ((sys.maxsize + 1) * 2)
                    cur = db.execute(QUERY_FMT % (key))
                    row = cur.fetchone()

                    if row is None:
                        db.execute(INSERT_FMT %
                                   (key, book, page, time, mark), False)
                    else:
                        if verbose:
                            print('Item skip: %s' % (row))
                        pass


class KlipFrame(wx.Frame):
    """
    """

    def __init__(self):
        """
        """

        super(KlipFrame, self).__init__(None, size=wx.Size(800, 600))
        # ensure the parent's __init__ is called

        self.SetMinSize(wx.Size(800, 600))

        sp = wx.SplitterWindow(self, style=wx.SP_BORDER | wx.SP_3DBORDER)
        sp.SetSplitMode(wx.SPLIT_VERTICAL)
        sp.SetMinimumPaneSize(50)

        # create a panel in the frame
        pnl_books = wx.Panel(sp)
        pnl_clips = wx.Panel(sp)
        pnl_clips.SetBackgroundColour(wx.Colour(255, 255, 255))

        sp.SplitVertically(pnl_books, pnl_clips, int(
            round(self.GetSize().GetWidth() * 0.4)))

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(wx.Button(pnl_books, -1, 'Search box will be here'),
                  0, wx.EXPAND, 0)

        # and put some text with a larger bold font on it
        id = wx.NewId()
        self.book_list = wx.ListView(
            pnl_books, id,
            style=wx.LC_REPORT | wx.SUNKEN_BORDER | wx.LC_NO_HEADER | wx.LC_SINGLE_SEL)

        self.book_list.InsertColumn(0, "Book")
        self.book_list.Show(True)

        sizer.Add(self.book_list, 1, wx.EXPAND, 0)

        pnl_books.SetSizer(sizer)

        # 0 will insert at the start of the list
        pos = self.book_list.InsertStringItem(0, "book 1")
        pos = self.book_list.InsertStringItem(1, "book 2")
        pos = self.book_list.InsertStringItem(2, "book 3")
        pos = self.book_list.InsertStringItem(3, "book 4")

        st2 = wx.StaticText(pnl_clips, label="Hello World2!", pos=(25, 25))
        font = st2.GetFont()
        font.PointSize += 10
        font = font.Bold()
        st2.SetFont(font)

        # create a menu bar
        self.makeMenuBar()

    def makeMenuBar(self):
        """
        A menu bar is composed of menus, which are composed of menu items.
        This method builds a set of menus and binds handlers to be called
        when the menu item is selected.
        """

        # Make a file menu with Hello and Exit items
        fileMenu = wx.Menu()
        # The "\t..." syntax defines an accelerator key that also triggers
        # the same event
        helloItem = fileMenu.Append(-1, "&Hello...\tCtrl-H",
                                    "Help string shown in status bar for this menu item")
        fileMenu.AppendSeparator()
        # When using a stock ID we don't need to specify the menu item's
        # label
        exitItem = fileMenu.Append(wx.ID_EXIT)

        # Now a help menu for the about item
        helpMenu = wx.Menu()
        aboutItem = helpMenu.Append(wx.ID_ABOUT)

        # Make the menu bar and add the two menus to it. The '&' defines
        # that the next letter is the "mnemonic" for the menu item. On the
        # platforms that support it those letters are underlined and can be
        # triggered from the keyboard.
        menuBar = wx.MenuBar()
        menuBar.Append(fileMenu, "&File")
        menuBar.Append(helpMenu, "&Help")

        # Give the menu bar to the frame
        self.SetMenuBar(menuBar)

        # Finally, associate a handler function with the EVT_MENU event for
        # each of the menu items. That means that when that menu item is
        # activated then the associated handler function will be called.
        self.Bind(wx.EVT_MENU, self.OnHello, helloItem)
        self.Bind(wx.EVT_MENU, self.OnExit,  exitItem)
        self.Bind(wx.EVT_MENU, self.OnAbout, aboutItem)

    def OnExit(self, event):
        """Close the frame, terminating the application."""
        self.Close(True)

    def OnHello(self, event):
        """Say hello to the user."""
        wx.MessageBox("Hello again from wxPython")

    def OnAbout(self, event):
        """Display an About Dialog"""
        wx.MessageBox("This is a wxPython Hello World sample",
                      "About Hello World 2",
                      wx.OK | wx.ICON_INFORMATION)


def start_app():
    """
    """
    app = wx.App()
    frm = KlipFrame()

    # Show it.
    frm.Show()
    app.MainLoop()
    pass


if __name__ == '__main__':
    # main()
    start_app()
